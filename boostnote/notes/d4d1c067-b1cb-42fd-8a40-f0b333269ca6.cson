createdAt: "2018-09-07T05:52:07.205Z"
updatedAt: "2018-09-07T05:52:20.523Z"
type: "MARKDOWN_NOTE"
folder: "b128952beebbe3794ae4"
title: "A 1091"
content: '''
  # A 1091
  ```C++
  #define _CRT_SECURE_NO_WARNINGS
  #include<cstdio>
  #include<math.h>
  #include<string.h>
  #include<iostream>
  #include<queue>
  #include<algorithm>
  int X[6] = { 0,0,0,0,1,-1 };
  int Y[6] = { 0,0,1,-1,0,0 };
  int Z[6] = { 1,-1,0,0,0,0 };
  int matrix[61][1290][130];
  bool inq[61][1290][130] = { false };
  int m, n, l, t;
  
  struct Node {
  	int z, y, x;
  }node;
  
  bool Judge(int z, int y, int x)
  {
  	if (z < 0 || z >= l || y < 0 || y >= m || x < 0 || x >= n)
  		return false;
  	if (matrix[z][y][x] == 0 || inq[z][y][x] == true)
  		return false;
  	return true;
  }
  
  int BFS(int z, int y, int x)
  {
  	int newZ, newY, newX;
  	int num = 0;
  	std::queue<Node>q;
  	node.z = z, node.y = y, node.x = x;
  	q.push(node);
  	inq[z][y][x] = true;
  	while (!q.empty())
  	{
  		Node top = q.front();
  		q.pop();
  		num++;
  		for (int i = 0; i < 6; i++)
  		{
  			newZ = top.z + Z[i];
  			newY = top.y + Y[i];
  			newX = top.x + X[i];
  			if (Judge(newZ, newY, newX))
  			{
  				node.z = newZ, node.y = newY, node.x = newX;
  				q.push(node);
  				inq[newZ][newY][newX]=true;
  			}
  		}
  	}
  	if (num >= t)
  		return num;
  	else
  		return 0;
  	
  
  }
  
  int main()
  {
  	
  
  	
  	scanf("%d %d %d %d", &m, &n, &l, &t);
  	for (int z = 0; z < l; z++)
  	{
  		for (int y = 0; y < m; y++)
  		{
  			for (int x = 0; x < n; x++)
  			{
  				scanf("%d", &matrix[z][y][x]);
  			}
  		}
  	}
  
  	int ans = 0;
  	for (int z = 0; z < l; z++)
  	{
  		for (int y = 0; y < m; y++)
  		{
  			for (int x = 0; x < n; x++)
  			{
  				if (matrix[z][y][x] == 1 && inq[z][y][x] == false)
  				{
  					ans += BFS(z, y, x);
  				}
  			}
  		}
  	}
  
  	printf("%d\\n", ans);
  
  }
  ```
'''
tags: []
isStarred: false
isTrashed: false
